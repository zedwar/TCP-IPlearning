##第一章浏览器生成消息
    ###生成HTTP请求消息
    用户在浏览器中输入网址（URL）开始。接下来，浏览器的工作会从对用户输入的网址进行解析开始 
    然后，浏览器会根据网址的含义来生成请求消息。浏览器通过请求消息将用户需要哪些数据告知服务器
    ###向DNS服务器查询Web服务器的IP地址
    请求消息生成之后，浏览器会委托操作系统向Web服务器发送请求，但浏览器必须告诉操作系统接收方的IP地址才行，因此浏览器必须先查出Web
        服务器的IP地址。网址中只有Web服务器的域名，因此浏览器需要向DNS服务器查询域名对应的IP地址
    ###全世界DNS服务器的大接力
    我们的旅程进入到了DNS服务器帮助浏览器查询IP地址这一环节了。全世界共有上万台DNS服务器，它们相互接力才能完成IP地址的查询
    ###委托协议栈发送消息
    查询到IP地址之后，浏览器就可以将消息委托给操作系统发送给Web服务器了
    ###1.1生成HTTP请求消息
    网址，准确来说应该叫URL；之所以有各种各样的URL，是因为尽管我们通常是使用浏览器来访问Web服务器的，但实际上浏览器并不只有这一个
        功能，它也可以用来在FTP[插图]服务器上下载和上传文件，同时也具备电子邮件客户端的功能
    根据访问目标的不同，URL的写法也会不同。例如在访问Web服务器和FTP服务器时，URL中会包含服务器的域名[插图]和要访问的文件的路径名
        等，而发邮件的URL则包含收件人的邮件地址。此外，根据需要，URL中还会包含用户名、密码、服务器端口号[插图]等信息
    那就是URL开头的文字，即“http:”“ftp:”“file:”“mailto:”这部分文字都表示浏览器应当使用的访问方法。比如当访问Web服务器时应该使用
        HTTP[插图]协议，而访问FTP服务器时则应该使用FTP协议
    浏览器要做的第一步工作就是对URL进行解析，从而生成发送给Web服务器的请求消息
    没有文件名，服务器怎么知道要访问哪个文件呢？其实，我们会在服务器上事先设置好文件名省略时要访问的默认文件名
    解析完URL之后，我们就知道应该要访问的目标在哪里了。接下来，浏览器会使用HTTP协议来访问Web服务器
    HTTP协议定义了客户端和服务器之间交互的消息内容和步骤，其基本思路非常简单。首先，客户端会向服务器发送请求消息（图1.4）。请求消
        息中包含的内容是“对什么”和“进行怎样的操作”两个部分。其中相当于“对什么”的部分称为URI[插图]。一般来说，URI的内容是一个存放
        网页数据的文件名或者是一个CGI程序[插图]的文件名，例如“/dir1/file1.html”“/dir1/program1.cgi”等[插图]。不过，URI不仅限于
        此，也可以直接使用“http:”开头的URL[插图]来作为URI。换句话说就是，这里可以写各种访问目标，而这些访问目标统称为URI。
    相当于接下来“进行怎样的操作”的部分称为方法[插图]。方法表示需要让Web服务器完成怎样的工作，其中典型的例子包括读取URI表示的数据、
        将客户端输入的数据发送给URI表示的程序等
    HTTP消息中还有一些用来表示附加信息的头字段。客户端向Web服务器发送数据时，会先发送头字段，然后再发送数据。不过，头字段属于可有
        可无的附加信息
    当我们访问Web服务器时，遇到找不到的文件就会显示出404 Not Found的错误信息，其实这就是状态码。状态码后面就是头字段和网页数据。
        响应消息会被发送回客户端，客户端收到之后，浏览器会从消息中读出所需的数据并显示在屏幕上。到这里，HTTP的整个工作就完成了。
    一般当我们访问Web服务器获取网页数据时，使用的就是GET方法。所谓一般的访问过程大概就是这样的：首先，在请求消息中写上GET方法，然
        后在URI中写上存放网页数据的文件名“/dir1/file1.html”，这就表示我们需要获取/dir1/file1.html文件中的数据。当Web服务器收到
        消息后，会打开/dir1/file1.html文件并读取出里面的数据，然后将读出的数据存放到响应消息中，并返回给客户端。最后，客户端浏览
        器会收到这些数据并显示在屏幕上。
    使用POST方法时，URI会指向Web服务器中运行的一个应用程序[插图]的文件名，典型的例子包括“index.cgi”“index.php”等。然后，在请求
        消息中，除了方法和URI之外，还要加上传递给应用程序和脚本的数据。这里的数据也就是用户在输入框里填写的信息。当服务器收到消息
        后，Web服务器会将请求消息中的数据发送给URI指定的应用程序。最后，Web服务器从应用程序接收输出的结果，会将它存放到响应消息中
        并返回给客户端。
    对URL进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生成HTTP请求消息了。实际上，HTTP消息在格式上是有严
        格规定的，因此浏览器会按照规定的格式来生成请求消息
    首先，请求消息的第一行称为请求行。这里的重点是最开头的方法，方法可以告诉Web服务器它应该进行怎样的操作。不过这里必须先解决一个
        问题，那就是方法有很多种，我们必须先判断应该选用其中的哪一种。解决这个问题的关键在于浏览器的工作状态。这次探索之旅是从在浏
        览器顶部的地址栏中输入网址开始的，但浏览器并非只有在这一种场景下才会向Web服务器发送请求消息。比如点击网页中的超级链接[插图]
        ，或者在表单中填写信息后点击“提交”按钮，这些场景都会触发浏览器的工作，而选用哪种方法也是根据场景来确定的
    第一行的末尾需要写上HTTP的版本号，这是为了表示该消息是基于哪个版本的HTTP规格编写的。到此为止，第一行就结束了。第二行开始为消息
        头。尽管通过第一行我们就可以大致理解请求的内容，但有些情况下还需要一些额外的详细信息，而消息头的功能就是用来存放这些信息。
        消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最
        后更新时间等。这些项目表示的都是非常细节的信息，因此要想准确理解这些信息的意思，就需要对HTTP协议有非常深入的了解。表1.2中
        列举了主要的头字段供大家参考，但不必全部弄明白。消息头中的内容随着浏览器类型、版本号、设置等的不同而不同，大多数情况下消息
        头的长度为几行到十几行不等。
    写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据。这一部分称为消息体，也就是消息的主体。不过，在使用GET
        方法的情况下，仅凭方法和URI, Web服务器就能够判断需要进行怎样的操作，因此消息体中不需要填写任何数据。消息体结束之后，整个
        消息也就结束了。
    当使用POST方法时，需要将表单中填写的信息写在消息体中。到此为止，请求消息的生成操作就全部完成了
    响应消息的格式以及基本思路和请求消息是相同的（图1.5（b）），差别只在第一行上。在响应消息中，第一行的内容为状态码和响应短语，用
        来表示请求的执行结果是成功还是出错。状态码和响应短语表示的内容一致，但它们的用途不同。状态码是一个数字，它主要用来向程序告
        知执行的结果（表1.3）；相对地，响应短语则是一段文字，用来向人们告知执行的结果。
    返回响应消息之后，浏览器会将数据提取出来并显示在屏幕上，我们就能够看到网页的样子了。如果网页的内容只有文字，那么到这里就全部处理完毕了
    当网页中包含图片时，会在网页中的相应位置嵌入表示图片文件的标签[插图]的控制信息。浏览器会在显示文字时搜索相应的标签，当遇到图片
        相关的标签时，会在屏幕上留出用来显示图片的空间，然后再次访问Web服务器，按照标签中指定的文件名向Web服务器请求获取相应的图片
        并显示在预留的空间中。这个步骤和获取网页文件时一样，只要在URI部分写上图片的文件名并生成和发送请求消息就可以了
    由于每条请求消息中只能写1个URI，所以每次只能获取1个文件，如果需要获取多个文件，必须对每个文件单独发送1条请求。比如1个网页中包
        含3张图片，那么获取网页加上获取图片，一共需要向Web服务器发送4条请求。判断所需的文件，然后获取这些文件并显示在屏幕上，这一
        系列工作的整体指挥也是浏览器的任务之一，而Web服务器却毫不知情。Web服务器完全不关心这4条请求获取的文件到底是1个网页上的还
        是不同网页上的，它的任务就是对每一条单独的请求返回1条响应而已。
    ###1.2向DNS服务器查询Web服务器的IP地址
    生成HTTP消息之后，接下来我们需要委托操作系统将消息发送给Web服务器。尽管浏览器能够解析网址并生成HTTP消息，但它本身并不具备将消
        息发送到网络中的功能，因此这一功能需要委托操作系统来实现
    在进行这一操作时，我们还有一个工作需要完成，那就是查询网址中服务器域名对应的IP地址。在委托操作系统发送消息时，必须要提供的不是
        通信对象的域名，而是它的IP地址。因此，在生成HTTP消息之后，下一个步骤就是根据域名查询IP地址。
    互联网和公司内部的局域网都是基于TCP/IP的思路来设计的，所以我们先来了解TCP/IP的基本思路。TCP/IP的结构如图1.8所示，就是由一些小
        的子网，通过路由器[插图]连接起来组成一个大的网络。这里的子网可以理解为用集线器[插图]连接起来的几台计算机[插图]，我们将它看
        作一个单位，称为子网。将子网通过路由器连接起来，就形成了一个网络
    在网络中，所有的设备都会被分配一个地址。这个地址就相当于现实中某条路上的“××号××室”。其中“号”对应的号码是分配给整个子网的，而
        “室”对应的号码是分配给子网中的计算机的，这就是网络中的地址。“号”对应的号码称为网络号，“室”对应的号码称为主机号，这个地址
        的整体称为IP地址[插图]。通过IP地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。消息传送的具体过程在后面的
        章节有详细讲解，不过现在我们先简单了解一下。发送者发出的消息首先经过子网中的集线器[插图]，转发到距离发送者最近的路由器上
        （图1.8①）。接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器，即消息再次经过子网内的
        集线器被转发到下一个路由器（图1.8②）。前面的过程不断重复，最终消息就被传送到了目的地
    TCP/IP网络是通过IP地址来确定通信对象的，因此不知道IP地址就无法将消息发送给对方，这和我们打电话的时候必须要知道对方的电话号码
        是一个道理。因此，在委托操作系统发送消息时，必须要先查询好对方的IP地址
    于是，现在我们使用的方案是让人来使用名称，让路由器来使用IP地址。为了填补两者之间的障碍，需要有一个机制能够通过名称来查询IP地
        址，或者通过IP地址来查询名称，这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。
    向DNS服务器发出查询，也就是向DNS服务器发送查询消息，并接收服务器返回的响应消息。换句话说，对于DNS服务器，我们的计算机上一定有
        相应的DNS客户端，而相当于DNS客户端的部分称为DNS解析器，或者简称解析器。通过DNS查询IP地址的操作称为域名解析，因此负责执行
        解析（resolution）这一操作的就叫解析器（resolver）了
    解析器实际上是一段程序，它包含在操作系统的Socket库中，在介绍解析器之前，我们先来简单了解一下Socket库。首先，库到底是什么东西
        呢？库就是一堆通用程序组件的集合，其他的应用程序都需要使用其中的组件。库有很多好处。首先，使用现成的组件搭建应用程序可以节
        省编程工作量；其次，多个程序使用相同的组件可以实现程序的标准化。除此之外还有很多其他的好处，因此使用库来进行软件开发的思路
        已经非常普及，库的种类和数量也非常之多。Socket库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能
        [插图]，而解析器就是这个库中的其中一种程序组件。
    解析器的用法非常简单。Socket库中的程序都是标准组件，只要从应用程序中进行调用就可以了。具体来说，在编写浏览器等应用程序的时候，
        只要像图1.11这样写上解析器的程序名称“gethostbyname”以及Web服务器的域名“www.lab.glasscom.com”就可以了，这样就完成了对解
        析器的调用
    ###1.3全世界DNS服务器的大接力
    DNS服务器的基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响应
    （a）域名服务器、邮件服务器（邮件地址中@后面的部分）的名称（b） Class在最早设计DNS方案时，DNS在互联网以外的其他网络中的应用也
        被考虑到了，而Class就是用来识别网络的信息。不过，如今除了互联网并没有其他的网络了，因此Class的值永远是代表互联网的IN
        （c）记录类型表示域名对应何种类型的记录。例如，当类型为A时，表示域名对应的是IP地址；当类型为MX时，表示域名对应的是邮件服
        务器。对于不同的记录类型，服务器向客户端返回的信息也会不同
    DNS服务器会从已有的记录中查找域名、Class和记录类型全部匹配的记录。假如DNS服务器中的记录如图1.14所示，那么第一行记录与查询消息
        中的3个项目完全一致。于是，DNS服务器会将记录中的192.0.2.226这个值返回给客户端
    互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台DNS服务器中是不可能的，因此一定会出现在DNS服务器中找不到要查
        询的信息的情况。下面来看一看此时DNS服务器是如何工作的。
    就是将信息分布保存在多台DNS服务器中，这些DNS服务器相互接力配合，从而查找出要查询的信息
    首先，DNS服务器中的所有信息都是按照域名以分层次的结构来保存的
    在域名中，越靠右的位置表示其层级越高，比如www.lab.glasscom.com这个域名如果按照公司里的组织结构来说，大概就是“com事业集团glasscom部lab科的www”这样。
    互联网中有数万台DNS服务器，肯定不能一台一台挨个去找。我们可以采用下面的办法。首先，将负责管理下级域的DNS服务器的IP地址注册到
        它们的上级DNS服务器中，然后上级DNS服务器的IP地址再注册到更上一级的DNS服务器中，以此类推。也就是说，负责管理lab.glasscom.com
        这个域的DNS服务器的IP地址需要注册到glasscom.com域的DNS服务器中，而glasscom.com域的DNS服务器的IP地址又需要注册到com域的DNS服务器中
    那就是将根域的DNS服务器信息保存在互联网中所有的DNS服务器中。这样一来，任何DNS服务器就都可以找到并访问根域DNS服务器了。因此，
        客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器
        （图1.15）。分配给根域DNS服务器的IP地址在全世界仅有13个[插图]，而且这些地址几乎不发生变化，因此将这些地址保存在所有的DNS
        服务器中也并不是一件难事
    有时候并不需要从最上级的根域开始查找，因为DNS服务器有一个缓存[插图]功能，可以记住之前查询过的域名。如果要查询的域名和相关信息
        已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行
    ###1.4委托协议栈发送消息
    向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用Socket库中的程序组件
    首先，服务器一方先创建套接字，然后等待客户端向该套接字连接管道[插图]。当服务器进入等待状态时，客户端就可以连接管道了。具体来
        说，客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务器端的套接字上。当双方的套接字连接起来之后，通
        信准备就完成了。接下来，就像我们刚刚讲过的一样，只要将数据送入套接字就可以收发数据了。
    综上所述，收发数据的操作分为若干个阶段，可以大致总结为以下4个。（1）创建套接字（创建套接字阶段）（2）将管道连接到服务器端的套
        接字上（连接阶段）（3）收发数据（通信阶段）（4）断开管道并删除套接字（断开阶段）
    我们需要委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序通过调用Socket库中的名为connect的程序组件来完成这
        一操作。这里的要点是当调用connect时，需要指定描述符、服务器IP地址和端口号这3个参数
    当套接字连接起来之后，剩下的事情就简单了。只要将数据送入套接字，数据就会被发送到对方的套接字中。
    断开的过程如下。Web使用的HTTP协议规定，当Web服务器发送完响应消息之后，应该主动执行断开操作[插图]，因此Web服务器会首先调用close
        来断开连接。断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。接下来，当浏览器调用read执行接收数据操作时，read会
        告知浏览器收发数据操作已结束，连接已经断开。浏览器得知后，也会调用close进入断开阶段。
##第二章用电信号传输TCP/IP数据
    （1）创建套接字从应用程序收到委托后，协议栈通过TCP协议收发数据的操作可以分为4个阶段。首先是创建套接字，在这个阶段，我们将介绍
        协议栈的内部结构、套接字的实体，以及创建套接字的操作过程。到这里，大家应该可以对套接字到底是什么样的一个东西有一个比较具
        体的理解。
    （2）连接服务器接下来是客户端套接字向服务器套接字进行连接的阶段。我们将介绍“连接”具体是进行怎样的操作，在这个过程中协议栈到底
        是如何工作的，以及客户端和服务器是如何进行交互的。
    （3）收发数据两端的套接字完成连接之后，就进入收发消息的阶段了。在这个阶段，协议栈会将从应用程序收到的数据切成小块并发送给服务
        器，考虑到通信过程中可能会出错导致网络包丢失，协议栈还需要确认切分出的每个包是否已经送达服务器，对于没有送达的包要重新发
        送一次。这里我们将对收发数据的情形加以说明。
    （4）从服务器断开连接并删除套接字收发消息的操作全部结束之后，接下来要断开服务器的连接并删除套接字。断开操作的本质是当消息收发
        完成后客户端和服务器相互进行确认的过程，但这个过程并不只是相互确认并删除套接字那么简单，其中有些地方是很有意思的。
    （5）IP与以太网的包收发操作在介绍TCP协议收发消息的操作之后，我们再来看看实际的网络包是如何进行收发的。协议栈会与网卡进行配合，
        将数据切分成小块并封装成网络包，再将网络包转换成电信号或者光信号发送出去。介绍完这个过程之后，大家应该就可以对计算机网络
        功能有一个完整的概念了。
    （6）用UDP协议收发数据的操作TCP协议有很多方便的功能，比如网络包出错丢失时可以重发，因此很多应用程序都是使用TCP协议来收发数据
        的，但这些方便的功能也有帮倒忙的时候，在这种情况下我们还有另外一种叫UDP的协议。这里我们将介绍UDP的必要性以及它与TCP的差异    
    ###2.1创建套接字
    ####2.1.1协议栈
    最上面的部分是网络应用程序，也就是浏览器、电子邮件客户端、Web服务器、电子邮件服务器等程序，它们会将收发数据等工作委派给下层的
        部分来完成
    应用程序的下面是Socket库，其中包括解析器，解析器用来向DNS服务器发出查询
    再下面就是操作系统内部了，其中包括协议栈。协议栈的上半部分有两块，分别是负责用TCP协议收发数据的部分和负责用UDP协议收发数据的
        部分，它们会接受应用程序的委托执行收发数据的操作。
    像浏览器、邮件等一般的应用程序都是使用TCP收发数据的，而像DNS查询等收发较短的控制数据的时候则使用UDP。
    下面一半是用IP协议控制网络包收发操作的部分。在互联网上传送数据时，数据会被切分成一个一个的网络包[插图]，而将网络包发送给通信对
        象的操作就是由IP来负责的。此外，IP中还包括ICMP[插图]协议和ARP[插图]协议。ICMP用于告知网络包传送过程中产生的错误以及各种
        控制消息，ARP用于根据IP地址查询相应的以太网MAC地址
    IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。
    ####2.1.2套接字的实体就是通信控制信息
    在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP地址、端口号、通信操作的
        进行状态等。本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，
        或者说存放控制信息的内存空间就是套接字的实体。协议栈在执行操作时需要参阅这些控制信息
    套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。
    ####2.1.3调用socket时的操作
    首先是创建套接字的阶段，在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。用于记录套接字控制信息的内存空间并不是
        一开始就存在的，因此我们先要开辟出这样一块空间来[插图]，这相当于为控制信息准备一个容器。但光一个容器并没有什么用，还需要往
        里面存入控制信息。套接字刚刚创建时，数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。到
        这里，创建套接字的操作就完成了。    
    接下来，需要将表示这个套接字的描述符告知应用程序。描述符相当于用来区分协议栈中的多个套接字的号码牌；收到描述符之后，应用程序在
        向协议栈进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符
        确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了
    ###2.2连接服务器
    创建套接字之后，应用程序（浏览器）就会调用connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。
    网线是一直连接着的，随时都有信号从中流过，如果通信过程只是将数据转换为电信号，那么这一操作随时都可以进行。
    套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。在这个状态下，即便应用程序要求发送数据，协议栈也不知
        道数据应该发送给谁。浏览器可以根据网址来查询服务器的IP地址，而且根据规则也知道应该使用80号端口，但只有浏览器知道这些必要的
        信息是不够的，因为在调用socket创建套接字时，这些信息并没有传递给协议栈。因此，我们需要把服务器的IP地址和端口号等信息告知协
        议栈，这是连接操作的目的之一。
    服务器上也会创建套接字[插图]，但服务器上的协议栈和客户端一样，只创建套接字是不知道应该和谁进行通信的。而且，和客户端不同的是，
        在服务器上，连应用程序也不知道通信对象是谁，这样下去永远也没法开始通信。于是，我们需要让客户端向服务器告知必要的信息，比如
        “我想和你开始通信，我的IP地址是xxx.xxx. xxx.xxx，端口号是yyyy。”
    连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作，像上面提到的客户端将IP地址和端口号告知
        服务器这样的过程就属于交换控制信息的一个具体的例子。所谓控制信息，就是用来控制数据收发操作所需的一些信息，IP地址和端口号就
        是典型的例子。
    连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备。此
        外，当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程
        中分配的
    控制信息其实可以大体上分为两类：第一类是客户端和服务器相互联络时交换的控制信息。这些信息不仅连接时需要，包括数据收发和断开连接
        操作在内，整个通信过程中都需要，这些内容在TCP协议的规格中进行了定义，这些字段是固定的，在连接、收发、断开等各个阶段中，每
        次客户端和服务器之间进行通信时，都需要提供这些控制信息。
        控制信息还有另外一类，那就是保存在套接字中，用来控制协议栈操作的信息[插图]。应用程序传递来的信息以及从通信对象接收到的信息
        都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作
    因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立
    从应用程序调用Socket库的connect开始，提供了服务器的IP地址和端口号，这些信息会传递给协议栈中的TCP模块。然后，TCP模块会与该IP
        地址对应的对象，也就是与服务器的TCP模块交换控制信息，这一交互过程包括下面几个步骤。首先，客户端先创建一个包含表示开始数据
        收发操作的控制信息的头部。如表2.1所示，头部包含很多字段，这里要关注的重点是发送方和接收方的端口号。到这里，客户端（发送方）
        的套接字就准确找到了服务器（接收方）的套接字，也就是搞清楚了我应该连接哪个套接字。然后，我们将头部中的控制位的SYN比特设置
        为1，大家可以认为它表示连接[插图]。此外还需要设置适当的序号和窗口大小，这一点我们会稍后详细讲解。
    当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送[插图]。IP模块执行网络包发送操作后，网络包就会通过网络
        到达服务器，然后服务器上的IP模块会将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部中的信息找到端口号对应的套接字，
        也就是说，从处于等待连接状态的套接字中找到与TCP头部中记录的端口号相同的套接字就可以了。
    [插图]。此外，在返回响应时还需要将ACK控制位设为1[插图]，这表示已经接收到相应的网络包。网络中经常会发生错误，网络包也会发生丢
        失，因此双方在通信时必须相互确认网络包是否已经送达[插图]，而设置ACK比特就是用来进行这一确认的。接下来，服务器TCP模块会将
        TCP头部传递给IP模块，并委托IP模块向客户端返回响应。
    网络包就会返回到客户端，通过IP模块到达TCP模块，并通过TCP头部的信息确认连接服务器的操作是否成功。如果SYN为1则表示连接成功，这
        时会向套接字中写入服务器的IP地址、端口号等信息，同时还会将状态改为连接完毕。到这里，客户端的操作就已经完成，但其实还剩下
        最后一个步骤。刚才服务器返回响应时将ACK比特设置为1，相应地，客户端也需要将ACK比特设置为1并发回服务器，告诉服务器刚才的响
        应包已经收到。当这个服务器收到这个返回包之后，连接操作才算全部完成。
    ###2.3收发数据
    ####2.3.1将HTTP请求消息交给协议栈
    当控制流程从connect回到应用程序之后，接下来就进入数据收发阶段了。数据收发操作是从应用程序调用write将要发送的数据交给协议栈开
        始的（图2.3③），协议栈收到数据后执行发送操作
    首先，协议栈并不关心应用程序传来的数据是什么内容。应用程序在调用write时会指定发送数据的长度，在协议栈看来，要发送的数据就是一
        定长度的二进制字节序列而已。
    其次，协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。这样做是有道理的。
        应用程序交给协议栈发送的数据长度是由应用程序本身来决定的，不同的应用程序在实现上有所不同，有些程序会一次性传递所有的数据，
        有些程序则会逐字节或者逐行传递数据。
    第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个叫作MTU[插图]的参数来进行判断。MTU表示一个网络包的最大长度，在以
        太网中一般是1500字节（图2.5）[插图]。MTU是包含头部的总长度，因此需要从MTU减去头部的长度，然后得到的长度就是一个网络包中
        所能容纳的最大数据长度，这一长度叫作MSS[插图]。当从应用程序收到的数据长度超过或者接近MSS时再发送出去，就可以避免发送大量
        小包的问题了
    另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近MSS时再发送，可能会因为等待时间太长而造成发送
        延迟，这种情况下，即便缓冲区中的数据长度没有达到MSS，也应该果断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之
        后，就会把网络包发送出去
    ####2.3.2对较大的数据进行拆分
    HTTP请求消息一般不会很长，一个网络包就能装得下，但如果其中要提交表单数据，长度就可能超过一个网络包所能容纳的数据量。这种情况
        下，发送缓冲区中的数据就会超过MSS的长度，这时我们当然不需要继续等待后面的数据了。发送缓冲区中的数据会被以MSS长度为单位进
        行拆分，拆分出来的每块数据会被放进单独的网络包中。
    ####2.3.3使用ACK号确认网络包已收到
    TCP具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作
    首先，TCP模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在TCP头部
        中，“序号”字段就是派在这个用场上的。然后，发送数据的长度也需要告知接收方，不过这个并不是放在TCP头部里面的，因为用整个网络
        包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。有了上面两个数值，我们就可以知道发送的数据
        是从第几个字节开始，长度是多少了
    通过这些信息，接收方还能够检查收到的网络包有没有遗漏。例如，假设上次接收到第1460字节，那么接下来如果收到序号为1461的包，说明
        中间没有遗漏；但如果收到的包序号为2921，那就说明中间有包遗漏了。像这样，如果确认没有遗漏，接收方会将到目前为止接收到的数
        据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入TCP头部的ACK号中发送给发送方
    通过序号和ACK号来进行数据确认的思路，但仅凭这些还不够，因为我们刚刚只考虑了单向的数据传输，但TCP数据收发是双向的，在客户端向
        服务器发送数据的同时，服务器也会向客户端发送数据，因此必须要想办法应对这样的情况。
    首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算ACK号并返回给客户端；相反地，服务器也需要先
        计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算ACK号并返回给服务器。此外，如图所示，客户端和服务器
        双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。
    因此，网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。应用程序也是一样，因为采用TCP传输，即便发生一
        些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好了。不过，如果发生网络中断、服务器宕机等问题，
        那么无论TCP怎样重传都不管用。这种情况下，无论如何尝试都是徒劳，因此TCP会在尝试几次重传无效之后强制结束通信，并向应用程序
        报错。
    ####2.3.5使用窗口有效管理ACK号
    每发送一个包就等待一个ACK号的方式是最简单也最容易理解的，但在等待ACK号的这段时间中，如果什么都不做那实在太浪费了。为了减少这样
        的浪费，TCP采用图2.10（b）这样的滑动窗口方式来管理数据发送和ACK号的操作。所谓滑动窗口，就是在发送一个包之后，不等待ACK号
        返回，而是直接发送后续的一系列包。这样一来，等待ACK号的这段时间就被有效利用起来了。
    虽然这样做能够减少等待ACK号时的时间浪费，但有一些问题需要注意。在一来一回方式中，接收方完成接收操作后返回ACK号，然后发送方收
        到ACK号之后才继续发送下一个包，因此不会出现发送的包太多接收方处理不过来的情况。但如果不等返回ACK号就连续发送包，就有可能
        会出现发送包的频率超过接收方处理能力的情况
    如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。缓冲区溢出之后，
        后面的数据就进不来了，因此接收方就收不到后面的包了，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力。我们可以
        通过下面的方法来避免这种情况的发生。首先，接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进
        行控制，这就是滑动窗口方式的基本思路
    ####2.3.6ACK与窗口的合并
    接收方在发送ACK号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可
        以把两种通知合并在一个包里面发送了
    ####2.3.7接收HTTP响应消息
    发送HTTP请求消息后，接下来还需要等待Web服务器返回响应消息。对于响应消息，浏览器需要进行接收操作，这一操作也需要协议栈的参与。
    首先，浏览器在委托协议栈发送请求消息之后，会调用read程序（之前的图2.3④）来获取响应消息。然后，控制流程会通过read转移到协议栈
        [插图]，然后协议栈会执行接下来的操作。和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下。首先，
        协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还
        需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。
    ###2.4从服务器断开并删除套接字
    ####2.4.1数据发送完毕后断开连接
    收发数据结束的时间点应该是应用程序判断所有数据都已经发送完毕的时候。这时，数据发送完毕的一方会发起断开过程，但不同的应用程序会
        选择不同的断开时机。以Web为例，浏览器向Web服务器发送请求消息，Web服务器再返回响应消息，这时收发数据的过程就全部结束了，服
        务器一方会发起断开过程
    首先，服务器一方的应用程序会调用Socket库的close程序。然后，服务器的协议栈会生成包含断开信息的TCP头部，具体来说就是将控制位中
        的FIN比特设为1。接下来，协议栈会委托IP模块向客户端发送数据（图2.12①）。同时，服务器的套接字中也会记录下断开操作的相关信息。
    接下来轮到客户端了。当收到服务器发来的FIN为1的TCP头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态。然后，为了告知
        服务器已收到FIN为1的包，客户端会向服务器返回一个ACK号（图2.12②）。这些操作完成后，协议栈就可以等待应用程序来取数据了
    应用程序就会调用read来读取数据[插图]。这时，协议栈不会向应用程序传递数据[插图]，而是会告知应用程序（浏览器）来自服务器的数据
        已经全部收到了。根据规则，服务器返回请求之后，Web通信操作就全部结束了，因此只要收到服务器返回的所有数据，客户端的操作也就
        随之结束了。
    客户端应用程序会调用close来结束数据收发操作，这时客户端的协议栈也会和服务器一样，生成一个FIN比特为1的TCP包，然后委托IP模块发
        送给服务器
    ####2.4.2删除套接字
    和服务器的通信结束之后，用来通信的套接字也就不会再使用了，这时我们就可以删除这个套接字了。不过，套接字并不会立即被删除，而是会
        等待一段时间之后再被删除。
    客户端先发起断开，则断开的操作顺序如下。（1）客户端发送FIN（2）服务器返回ACK号（3）服务器发送FIN（4）客户端返回ACK号
    ###2.5IP与以太网的包收发操作
    ####2.5.1包的基本知识
    TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成包发送给通信对象
    包是由头部和数据两部分构成的。头部包含目的地址等控制信息，大家可以把它理解为快递包裹的面单；头部后面就是委托方要发送给对方的数
        据，也就相当于快递包裹里的货物。
    首先，发送方的网络设备会负责创建包，创建包的过程就是生成含有正确控制信息的头部，然后再附加上要发送的数据。接下来，包会被发往最
        近的网络转发设备。当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里。这个过程需要用到一张表，这张
        表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个
        方向。接下来，包在向目的地移动的过程中，又会到达下一个转发设备，然后又会按照同样的方式被发往下一个转发设备。就这样，经过多
        个转发设备的接力之后，包最终就会到达接收方的网络设备。当然，发送方向接收方发送一个包，接收方可能也会向发送方返回一个包，此
        时的发送方到了接下来的某个时刻就会变成接收方。因此，我们不需要把发送方和接收方明确区分开来，在这里我们把发送方和接收方统称
        为终端节点
    网络中有路由器和集线器两种不同的转发设备，它们在传输网络包时有着各自的分工。（1）路由器根据目标地址判断下一个路由器的位置
        （2）集线器在子网中将网络包传输到下一个路由实际上，集线器是按照以太网规则传输包的设备，而路由器是按照IP规则传输包的设备，
        因此我们也可以作如下理解。（1）IP协议根据目标地址判断下一个IP转发设备的位置（2）子网中的以太网协议将包传输到下一个转发设备
    TCP/IP包包含如下两个头部。（a）MAC头部（用于以太网协议）（b）IP头部（用于IP协议）这两个头部分别具有不同的作用。首先，发送方将
        包的目的地，也就是要访问的服务器的IP地址写入IP头部中。这样一来，我们就知道这个包应该发往哪里，IP协议就可以根据这一地址查找
        包的传输方向，从而找到下一个路由器的位置，也就是图2.16中的路由器R1。接下来，IP协议会委托以太网协议将包传输过去。这时，IP协
        议会查找下一个路由器的以太网地址（MAC地址），并将这个地址写入MAC头部中。这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。
    网络包在传输过程中（图2.16①）会经过集线器，集线器是根据以太网协议工作的设备。为了判断包接下来应该向什么地方传输，集线器里有一张
        表（用于以太网协议的表），可根据以太网头部中记录的目的地信息查出相应的传输方向。这张图中只有一个集线器，当存在多个集线器时，
        网络包会按顺序逐一通过这些集线器进行传输
    接下来，包会到达下一个路由器（图2.16②）。路由器中有一张IP协议的表，可根据这张表以及IP头部中记录的目的地信息查出接下来应该发往
        哪个路由器。为了将包发到下一个路由器，我们还需要查出下一个路由器的MAC地址，并记录到MAC头部中，大家可以理解为改写了MAC头部
        [插图]。这样，网络包就又被发往下一个节点了
    前面介绍的就是在TCP/IP网络中，一个网络包从出发到到达目的地的全过程。虽然看起来有点复杂，不过设计这样的分工是有原因的。前面讲
        了IP和以太网的分工，其中以太网的部分也可以替换成其他的东西，例如无线局域网、ADSL、FTTH等，它们都可以替代以太网的角色帮助
        IP协议来传输网络包[插图]。因此，将IP和负责传输的网络分开，可以更好地根据需要使用各种通信技术。像互联网这样庞大复杂的网络，
        在架构上需要保证灵活性，这就是设计这种分工方式的原因。
    ####2.5.2包收发操作
    包收发操作的起点是TCP模块委托IP模块发送包的操作（图2.17中的“①发送”）。这个委托的过程就是TCP模块在数据块的前面加上TCP头部，然
        后整个传递给IP模块，这部分就是网络包的内容。与此同时，TCP模块还需要指定通信对象的IP地址，也就是需要写清楚“将什么内容发给谁”。
    收到委托后，IP模块会将包的内容当作一整块数据，在前面加上包含控制信息的头部。刚才我们讲过，IP模块会添加IP头部和MAC头部这两种头
        部。IP头部中包含IP协议规定的、根据IP地址将包发往目的地所需的控制信息；MAC头部包含通过以太网的局域网将包传输至最近的路由器
        所需的控制信息[插图]。关于IP头部和MAC头部的区别以及其中包含的控制信息的含义，我们将稍后介绍。总之，加上这两个头部之后，一
        个包就封装好了，这些就是IP模块负责的工作。
    接下来，封装好的包会被交给网络硬件（图2.17中的“②发送”），例如以太网、无线局域网等。网络硬件可能是插在计算机主板上的板卡，也可
        能是笔记本电脑上的PCMCIA卡，或者是计算机主板上集成的芯片，不同形态的硬件名字也不一样，本书将它们统称为网卡[插图]。传递给
        网卡的网络包是由一连串0和1组成的数字信息，网卡会将这些数字信息转换为电信号或光信号，并通过网线（或光纤）发送出去，然后这
        些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步地送达接收方
    包送达对方之后，对方会作出响应。返回的包也会通过转发设备发送回来，然后我们需要接收这个包。接收的过程和发送的过程是相反的，信息
        先以电信号的形式从网线传输进来，然后由网卡将其转换为数字信息并传递给IP模块（图2.17中的“③接收”）。接下来，IP模块会将MAC头
        部和IP头部后面的内容，也就是TCP头部加上数据块，传递给TCP模块。接下来的操作就是我们之前讲过的TCP模块负责的部分了。
    TCP模块在收发数据时会分为好几个阶段，并为各个阶段设计了实现相应功能的网络包，但IP的包收发操作都是相同的，并不会因包本身而有所
        区别。因为IP模块会将TCP头部和数据块看作一整块二进制数据，在执行收发操作时并不关心其中的内容，也不关心这个包是包含TCP头部
        和数据两者都有呢，还是只有TCP头部而没有数据。当然，IP模块也不关心TCP的操作阶段，对于包的乱序和丢失也一概不知。总之，IP的
        职责就是将委托的东西打包送到对方手里，或者是将对方送来的包接收下来，仅此而已。因此，接下来我们要讲的这些关于IP的工作方式，
        可适用于任何TCP委派的收发操作。
    ####2.5.3生成包含接收方IP地址的IP头部
    IP模块接受TCP模块的委托负责包的收发工作，它会生成IP头部并附加在TCP头部前面。IP头部包含的内容如表2.2所示，其中最重要的内容就
        是IP地址，它表示这个包应该发到哪里去。这个地址是由TCP模块告知的，而TCP又是在执行连接操作时从应用程序那里获得这个地址的，
        因此这个地址的最初来源就是应用程序。IP不会自行判断包的目的地，而是将包发往应用程序指定的接收方，即便应用程序指定了错误的IP
        地址，IP模块也只能照做
    头部中还需要填写发送方的IP地址，大家可以认为是发送方计算机的IP地址[插图]，实际上“计算机的IP地址”这种说法并不准确。一般的客户
        端计算机上只有一块网卡，因此也就只有一个IP地址，这种情况下我们可以认为这个IP地址就是计算机的IP地址，但如果计算机上有多个
        网卡，情况就没那么简单了。IP地址实际上并不是分配给计算机的，而是分配给网卡的，因此当计算机上存在多块网卡时，每一块网卡都
        会有自己的IP地址
    ####2.5.4生成以太网用的MAC头部
    生成了IP头部之后，接下来IP模块还需要在IP头部的前面加上MAC头部（表2.3）。IP头部中的接收方IP地址表示网络包的目的地，通过这个地
        址我们就可以判断要将包发到哪里，但在以太网的世界中，TCP/IP的这个思路是行不通的。以太网在判断网络包目的地时和TCP/IP的方式
        不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC头部就是干这个用的。
    ####2.5.5通过ARP查询目标路由器的MAC地址
    这里我们需要使用ARP[插图]，它其实非常简单。在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。ARP就
        是利用广播对所有设备提问：“××这个IP地址是谁的？请把你的MAC地址告诉我。”然后就会有人回答：“这个IP地址是我的，我的MAC地址是××××。”
    如果每次发送包都要这样查询一次，网络中就会增加很多ARP包，因此我们会将查询结果放到一块叫作ARP缓存的内存空间中留着以后用。也就
        是说，在发送包时，先查询一下ARP缓存，如果其中已经保存了对方的MAC地址，就不需要发送ARP查询，直接使用ARP缓存中的地址，而当
        ARP缓存中不存在对方MAC地址时，则发送ARP查询
    ####2.5.6以太网的基本知识
    以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术，它的原型如图2.22（a）所示。从图上不难看出，这种网络的本
        质其实就是一根网线。图上还有一种叫作收发器的小设备，它的功能只是将不同网线之间的信号连接起来而已。因此，当一台计算机发送信
        号时，信号就会通过网线流过整个网络，最终到达所有的设备。这就好像所有人待在一个大房间里，任何一个人说话，所有人都能够听到，
        同样地，这种网络中任何一台设备发送的信号所有设备都能接收到。不过，我们无法判断一个信号到底是发给谁的，因此需要在信号的开头
        加上接收者的信息，也就是地址。这样一来就能够判断信号的接收者了，与接收者地址匹配的设备就接收这个包，其他的设备则丢弃这个
        包，这样我们的包就送到指定的目的地了。为了控制这一操作，我们就需要使用表2.3中列出的MAC头部。通过MAC头部中的接收方MAC地址，
        就能够知道包是发给谁的；而通过发送方MAC地址，就能够知道包是谁发出的；此外，通过以太类型就可以判断包里面装了什么类型的内容。
        以太网其实就这么简单[插图]
    尽管以太网经历了数次变迁，但其基本的3个性质至今仍未改变，即将包发送到MAC头部的接收方MAC地址代表的目的地，用发送方MAC地址识别
        发送方，用以太类型识别包的内容。因此，大家可以认为具备这3个性质的网络就是以太网
    ####2.5.7将IP包转换成电或者光信号发送出去
    IP生成的网络包只是存放在内存中的一串数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电或光信号，才能在网线上传
        输，也就是说，这才是真正的数据发送过程。负责执行这一操作的是网卡，但网卡也无法单独工作，要控制网卡还需要网卡驱动程序。驱动
        程序不只有网卡才有，键盘、鼠标、显卡、声卡等各种硬件设备都有。当然，不同厂商和型号的网卡在结构上有所不同，因此网卡驱动程序
        也是厂商开发的专用程序
    网卡的ROM中保存着全世界唯一的MAC地址，这是在生产网卡时写入的，将这个值读出之后就可以对MAC模块进行设置，MAC模块就知道自己对应
        的MAC地址了。
    ####2.5.8给网络包再加3个控制数据
    网卡驱动从IP模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC模块发送发送包的命令
    首先，MAC模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列
    报头是一串像10101010…这样1和0交替出现的比特序列，长度为56比特，它的作用是确定包的读取时机。当这些1010的比特序列被转换成电信
        号后，会形成如图2.25这样的波形。接收方在收到信号时，遇到这样的波形就可以判断读取数据的时机。关于这一块内容，我们得先讲讲
        如何通过电信号来读取数据。
    用电信号来表达数字信息时，我们需要让0和1两种比特分别对应特定的电压和电流，例如图2.26（a）这样的电信号就可以表达数字信息。通过
        电信号来读取数据的过程就是将这种对应关系颠倒过来。也就是说，通过测量信号中的电压和电流变化，还原出0和1两种比特的值。然而，
        实际的信号并不像图2.26所示的那样有分隔每个比特的辅助线，因此在测量电压和电流时必须先判断出每个比特的界限在哪里。
    要解决这个问题，最简单的方法就是在数据信号之外再发送一组用来区分比特间隔的时钟信号。如图2.26（b）所示，当时钟信号从下往上变化
        时[插图]读取电压和电流的值，然后和0或1进行对应就可以了。但是这种方法存在问题。当距离较远，网线较长时，两条线路的长度会发生
        差异，数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移。
    要解决这个问题，可以采用将数据信号和时钟信号叠加在一起的方法。这样的信号如图2.26（c）所示，发送方将这样的信号发给接收方。由于
        时钟信号是像图2.26（b）这样按固定频率进行变化的，只要能够找到这个变化的周期，就可以从接收到的信号（c）中提取出时钟信号（b），
        进而通过接收信号（c）和时钟信号（b）计算出数据信号（a），这和发送方将数据信号和时钟信号进行叠加的过程正好相反。然后，只要
        根据时钟信号（b）的变化周期，我们就可以从数据信号（a）中读取相应的电压和电流值，并将其还原为0或1的比特了。
    末尾的FCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串32比特的序列，是通过一个公式对包中从头到尾
        的所有内容进行计算而得出来的。具体的计算公式在此省略，它和磁盘等设备中使用的CRC[插图]错误校验码是同一种东西，当原始数据中
        某一个比特发生变化时，计算出来的结果就会发生变化。在包传输过程中，如果受到噪声的干扰而导致其中的数据发生了变化，那么接收方
        计算出的FCS和发送方计算出的FCS就会不同，这样我们就可以判断出数据有没有错误。
    ####2.5.9向集线器发送网络包
    加上报头、起始帧分界符和FCS之后，我们就可以将包通过网线发送出去了（图2.24）。发送信号的操作分为两种，一种是使用集线器的半双工
        模式，另一种是使用交换机的全双工[插图]模式。
    在半双工模式中，为了避免信号碰撞，首先要判断网线中是否存在其他设备发送的信号。如果有，则需要等待该信号传输完毕，因为如果在有信
        号时再发送一组信号，两组信号就会发生碰撞。当之前的信号传输完毕，或者本来就没有信号在传输的情况下，我们就可以开始发送信号了。
    PHY（MAU）模块会将信号转换为可在网线上传输的格式，并通过网线发送出去。以太网规格中对不同的网线类型和速率以及其对应的信号格式进
        行了规定，但MAC模块并不关心这些区别，而是将可转换为任意格式的通用信号发送给PHY（MAU）模块，然后PHY（MAU）模块再将其转换为
        可在网线上传输的格式。
    ####2.5.10接收返回包
    在使用集线器的半双工模式以太网中，一台设备发送的信号会到达连接在集线器上的所有设备。这意味着无论是不是发给自己的信号都会通过接
        收线路传进来，因此接收操作的第一步就是不管三七二十一把这些信号全都收进来再说。
    中断是有编号的，网卡在安装的时候就在硬件中设置了中断号，在中断处理程序中则将硬件的中断号和相应的驱动程序绑定。例如，假设网卡的
        中断号为11，则在中断处理程序中将中断号11和相应的网卡驱动绑定起来，当网卡发起中断时，就会自动调用网卡驱动了。现在的硬件设备
        都遵循即插即用[插图]规范自动设置中断号，我们没必要去关心中断号了，在以前需要手动设置中断号的年代，经常发生因为设置了错误的
        中断号而导致网卡无法正常工作的问题。
    ####2.5.11将服务器的响应包从IP传递给TCP
     服务器返回的包的以太类型应该是0800，因此网卡驱动会将其交给TCP/IP协议栈来进行处理。接下来就轮到IP模块先开始工作了，第一步是检
        查IP头部，确认格式是否正确。如果格式没有问题，下一步就是查看接收方IP地址。如果接收网络包的设备是一台Windows客户端计算机，
        那么服务器返回的包的接收方IP地址应该与客户端网卡的地址一致，检查确认之后我们就可以接收这个包了 
     如果接收方IP地址正确，则这个包会被接收下来，这时还需要完成另一项工作。IP协议有一个叫作分片的功能，具体的内容我们将在第3章探
        索路由器时进行介绍。简单来说，网线和局域网中只能传输小包，因此需要将大的包切分成多个小包。如果接收到的包是经过分片的，那么
        IP模块会将它们还原成原始的包。分片的包会在IP头部的标志字段中进行标记，当收到分片的包时，IP模块会将其暂存在内部的内存空间中，
        然后等待IP头部中具有相同ID的包全部到达，这是因为同一个包的所有分片都具有相同的ID。
     ###2.6UDP的收发操作
     ####2.6.1不需要重发的数据使用UDP发送更高效
     有些应用程序不使用TCP协议，而是使用UDP协议来收发数据。向DNS服务器查询IP地址的时候我们用的也是UDP协议。下面就简单介绍一下UDP协议。
     不过，在某种情况下，即便没有TCP这样复杂的机制，我们也能够高效地重发数据，这种情况就是数据很短，用一个包就能装得下。如果只有一
        个包，就不用考虑哪个包未送达了，因为全部重发也只不过是重发一个包而已，这种情况下我们就不需要TCP这样复杂的机制了。而且，如
        果不使用TCP，也不需要发送那些用来建立和断开连接的控制包了。此外，我们发送了数据，对方一般都会给出回复，只要将回复的数据当
        作接收确认就行了，也不需要专门的接收确认包了。
     ####2.6.2控制用的短数据
     像DNS查询等交换控制信息的操作基本上都可以在一个包的大小范围内解决，这种场景中就可以用UDP来代替TCP[插图]。UDP没有TCP的接收确
        认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤，只要在从应用程序获取的数据前面
        加上UDP头部，然后交给IP进行发送就可以了（表2.5）。接收也很简单，只要根据IP头部中的接收方和发送方IP地址，以及UDP头部中的接
        收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了。
     还有另一个场景会使用UDP，就是发送音频和视频数据的时候。音频和视频数据必须在规定的时间内送达，一旦送达晚了，就会错过播放时机，
        导致声音和图像卡顿。如果像TCP一样通过接收确认响应来检查错误并重发，重发的过程需要消耗一定的时间，因此重发的数据很可能已经
        错过了播放的时机。一旦错过播放时机，重发数据也是没有用的，因为声音和图像已经卡顿了，这是无法挽回的。
##第三章从网线到网络设备
    （1）信号在网线和集线器中传输信号从计算机中流出之后，会在网线中经过集线器等设备前进。此时，信号是如何在网线和集线器传输的，就
        是我们的第一个看点。信号在传输过程中会衰减，还会受到噪声干扰而失真，如何抑制这些影响是我们的另一个看点。
    （2）交换机的包转发操作交换机的工作方式也是本章看点之一。交换机并不只是简单地让信号流过，而是先接收信号并将其还原为数字信息，
        然后再重新转换成信号并发送出去的过程。这里我们将详细探索这一过程。
    （3）路由器的包转发操作路由器和交换机一样也负责对包进行转发，但它们的工作方式有一些差异。交换机是基于以太网规格工作的设备，而
        路由器是基于IP工作的，它们之间的差异也是本章看点之一。
    （4）路由器的附加功能位于互联网接入端的路由器通常还会提供一些附加功能，例如将私有地址转换为公有地址的地址转换功能，以及阻止危
        险网络包的包过滤功能等。本章最后将介绍一下这些功能，这样我们就会对路由器有较全面的认识  
     ###3.1信号在网线和集线器中传输
     ####3.1.1每个包都是独立传输的
     转发设备会根据包头部中的控制信息，在转发设备内部一个写有转发规则的表中进行查询，以此来判断包的目的地，然后将包朝目的地的方向
        进行转发。
     HTTP请求的方法，TCP的确认响应和序号，客户端和服务器之间的关系，这一切都与包的传输无关。因此，所有的包在传输到目的地的过程中
        都是独立的，相互之间没有任何关联。
     ####3.1.2防止网线中的信号衰减很重要
     网卡中的PHY（MAU）[插图]模块负责将包转换成电信号，信号通过RJ-45接口进入双绞线，这部分的放大图如图3.2的右侧部分所示。以太网信
        号的本质是正负变化的电压，大家可以认为网卡的PHY（MAU）模块就是一个从正负两个信号端子输出信号的电路。
     但是，信号到达集线器的时候并不是跟刚发送出去的时候一模一样。集线器收到的信号有时会出现衰减（图3.3）。信号在网线的传输过程中，
        能量会逐渐损失。网线越长，信号衰减就越严重。
     即便线路条件很好，没有噪声，信号在传输过程中依然会发生失真，如果再加上噪声的影响，失真就会更厉害。噪声根据强度和类型会产生不
        同的影响，无法一概而论，但如果本来就已经衰减的信号再进一步失真，就会出现对0和1的误判，这就是产生通信错误的原因
     ####3.1.3“双绞”是为了抑制噪声
     局域网网线使用的是双绞线，其中“双绞”的意思就是以两根信号线为一组缠绕在一起，这种拧麻花一样的设计是为了抑制噪声的影响。
     首先，我们来看看噪声是如何产生的。产生噪声的原因是网线周围的电磁波，当电磁波接触到金属等导体时，在其中就会产生电流。因此，如
        果网线周围存在电磁波，就会在网线中产生和原本的信号不同的电流。由于信号本身也是一种带有电压变化的电流，其本质和噪声产生的电
        流是一样的，所以信号和噪声的电流就会混杂在一起，导致信号的波形发生失真，这就是噪声的影响。
     影响网线的电磁波分为两种。一种是由电机、荧光灯、CRT显示器等设备泄漏出来的电磁波，这种电磁波来自网线之外的其他设备，我们来看看
        双绞线如何抑制这种电磁波的影响。首先，信号线是用金属做成的，当电磁波接触到信号线时，会沿电磁波传播的右旋方向产生电流，这种
        电流会导致波形发生失真。如果我们将信号线缠绕在一起，信号线就变成了螺旋形，其中两根信号线中产生的噪声电流方向就会相反，从而
        使得噪声电流相互抵消，噪声就得到了抑制
     另一种电磁波是从网线中相邻的信号线泄漏出来的。由于传输的信号本身就是一种电流，当电流流过时就会向周围发出电磁波，这些电磁波对
        于其他信号线来说就成了噪声。这种内部产生的噪声称为串扰
     要抑制这种噪声，关键在于双绞线的缠绕方式。在一根网线中，每一对信号线的扭绞间隔（节距）都有一定的差异，这使得在某些地方正信号
        线距离近，另一些地方则是负信号线距离近。由于正负信号线产生的噪声影响是相反的，所以两者就会相互抵消
     ####3.1.4集线器将信号发往所有路线
     当信号到达集线器后，会被广播到整个网络中。以太网的基本架构[插图]就是将包发到所有的设备，然后由设备根据接收方MAC地址来判断应
        该接收哪些包，而集线器就是这一架构的忠实体现，它就是负责按照以太网的基本架构将信号广播出去。下面来看看它的工作方式。
     首先，在每个接口的后面装有和网卡中的PHY（MAU）功能相同的模块，但如果它们像网卡端一样采用直连式接线，是无法正常接收信号的。要正
        常接收信号，必须将“发送线路”和“接收线路”连接起来才行。在图3.2中，集线器中的PHY （MAU）模块与接口之间采用交叉接线的原因正
        是在于此。
     由于集线器的接口一般都是MDI-X模式，要将两台集线器相连时，就需要将其中一台改成MDI模式（图3.5（a））。如果集线器上没有MDI切换
        开关，而且所有的接口又都是MDI-X时，可以用交叉网线连接两台集线器。所谓交叉网线，就是一种将发送和接收信号线反过来接的网线
     信号到达集线器的PHY（MAU）模块后，会进入中继电路。中继电路的基本功能就是将输入的信号广播到集线器的所有端口上。当然，也有一些
        产品具有信号整形、错误抑制等功能，但基本上就是将输入的信号原封不动地输出到网线接口。
     信号从所有接口流出，到达连接在集线器上的所有设备。然后，这些设备在收到信号之后会通过MAC头部中的接收方MAC地址判断是不是发给自
        己的，如果是发给自己的就接受，否则就忽略[插图]。这样，网络包就能够到达指定MAC地址的接收方了。
     由于集线器只是原封不动地将信号广播出去，所以即便信号受到噪声的干扰发生了失真，也会原样发送到目的地。这时，接收信号的设备，也
        就是交换机、路由器、服务器等，会在将信号转换成数字信息后通过FCS[插图]校验发现错误，并将出错的包丢弃。当然，丢弃包并不会影
        响数据的传输，因为丢弃的包不会触发确认响应。因此协议栈的TCP模块会检测到丢包，并对该包进行重传。
     ###3.2交换机的包转发操作
     ####3.2.1交换机根据地址表进行转发
     首先，信号到达网线接口，并由PHY（MAU）模块进行接收，这一部分和集线器是相同的。也就是说，它的接口和PHY（MAU）模块也是以MDI-X
        模式进行连接的[插图]，当信号从双绞线传入时，就会进入PHY（MAU）模块的接收部分。
     接下来，PHY（MAU）模块会将网线中的信号转换为通用格式，然后传递给MAC模块。MAC模块将信号转换为数字信息，然后通过包末尾的FCS校
        验错误，如果没有问题则存放到缓冲区中
     但交换机的工作方式和网卡有一点不同。网卡本身具有MAC地址，并通过核对收到的包的接收方MAC地址判断是不是发给自己的，如果不是发给
        自己的则丢弃；相对地，交换机的端口不核对接收方MAC地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端
        口不具有MAC地址
     将包存入缓冲区后，接下来需要查询一下这个包的接收方MAC地址是否已经在MAC地址表中有记录了。MAC地址表主要包含两个信息，一个是设
        备的MAC地址，另一个是该设备连接在交换机的哪个端口上。以图3.7中的地址表为例，MAC地址和端口是一一对应的，通过这张表就能够判
        断出收到的包应该转发到哪个端口。
     交换电路的结构如图3.8所示，它可以将输入端和输出端连接起来。其中，信号线排列成网格状，每一个交叉点都有一个交换开关，交换开关
        是电子控制的，通过切换开关的状态就可以改变信号的流向。交换电路的输入端和输出端分别连接各个接收端口和发送端口，网络包通过
        这个网格状的电路在端口之间流动。
     根据以太网的规则，首先应该确认没有其他设备在发送信号，也就是确认信号收发模块中的接收线路没有信号进来。如果检测到其他设备在发
        送信号，则需要等待信号发送完毕；如果没有其他信号，或者其他信号已经发送完毕，这时就可以将包的数字信息转换为电信号发送出去。
        在发送信号的过程中，还需要对接收信号进行监控，这一点和网卡也是一样的。如果在发送过程中检测到其他设备发送信号，就意味着出现
        了信号碰撞，这时需要发送阻塞信号以停止网络中所有的发送操作，等待一段时间后再尝试重新发送，这一步和网卡也是一样的
     ####3.2.2MAC地址表的维护
     第一种是收到包时，将发送方MAC地址以及其输入端口的号码写入MAC地址表中。由于收到包的那个端口就连接着发送这个包的设备，所以只要
        将这个包的发送方MAC地址写入地址表，以后当收到发往这个地址的包时，交换机就可以将它转发到正确的端口了。交换机每次收到包时都
        会执行这个操作，因此只要某个设备发送过网络包，它的MAC地址就会被记录到地址表中。
     另一种是删除地址表中某条记录的操作，这是为了防止设备移动时产生问题。比如，我们在开会时会把笔记本电脑从办公桌拿到会议室，这时
        设备就发生了移动。从交换机的角度来看，就是本来连接在某个端口上的笔记本电脑消失了。这时如果交换机收到了发往这台已经消失的笔
        记本电脑的包，那么它依然会将包转发到原来的端口，通信就会出错，因此必须想办法删除那些过时的记录。然而，交换机没办法知道这台
        笔记本电脑已经从原来的端口移走了。因此地址表中的记录不能永久有效，而是要在一段时间不使用后就自动删除。
     ####3.2.3特殊操作
     就是地址表中找不到指定的MAC地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从
        地址表中删除了。这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接
        在哪个端口上都能收到这个包。这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接
        收包，而其他设备则会忽略这个包。
     ####3.2.4全双工模式可以同时进行发送和接收
     全双工模式是交换机特有的工作模式，它可以同时进行发送和接收操作，集线器不具备这样的特性。
     使用集线器时，如果多台计算机同时发送信号，信号就会在集线器内部混杂在一起，进而无法使用，这种现象称为碰撞，是以太网的一个重要
        特征。不过，只要不用集线器，就不会发生碰撞。
     在全双工模式下，无需等待其他信号结束就可以发送信号，因此它比半双工模式速度要快[插图]。由于双方可以同时发送数据，所以可同时传输
        的数据量也更大，性能也就更高。
     ####3.2.5自动协商：确定最优的传输速率
     随着全双工模式的出现，如何在全双工和半双工模式之间进行切换的问题[插图]也产生了。在全双工模式刚刚出现的时候，还需要手动进行切
        换，但这样实在太麻烦，于是后来出现了自动切换工作模式的功能。这一功能可以由相互连接的双方探测对方是否支持全双工模式，并自动
        切换成相应的工作模式。
     ####3.2.6交换机可同时执行多个转发操作
     交换机只将包转发到具有特定MAC地址的设备连接的端口，其他端口都是空闲的。
     ###3.3路由器的包转发操作
     ####3.3.1路由器的基本知识
     网络包经过集线器和交换机之后，现在到达了路由器，并在此被转发到下一个路由器。这一步转发的工作原理和交换机类似，也是通过查表判
        断包转发的目标。不过在具体的操作过程上，路由器和交换机是有区别的。因为路由器是基于IP设计的，而交换机是基于以太网设计的
     首先，路由器的内部结构如图3.12所示。这张图已经画得非常简略了，大家只要看明白路由器包括转发模块和端口模块两部分就可以了。其中
        转发模块负责判断包的转发目的地，端口模块负责包的收发操作。这一分工模式在第2章介绍计算机内部结构的时候也出现过，换句话说，
        路由器转发模块和端口模块的关系，就相当于协议栈的IP模块和网卡之间的关系。
     通过更换网卡，计算机不仅可以支持以太网，也可以支持无线局域网，路由器也是一样。如果路由器的端口模块安装了支持无线局域网的硬件，
        就可以支持无线局域网了。
     路由器在转发包时，首先会通过端口将发过来的包接收进来，这一步的工作过程取决于端口对应的通信技术。对于以太网端口来说，就是按照
        以太网规范进行工作，而无线局域网端口则按照无线局域网的规范工作，总之就是委托端口的硬件将包接收进来。接下来，转发模块会根据
        接收到的包的IP头部中记录的接收方IP地址，在路由表中进行查询，以此判断转发目标。然后，转发模块将包转移到转发目标对应的端口，
        端口再按照硬件的规则将包发送出去，也就是转发模块委托端口模块将包发送出去的意思
     刚才我们讲到端口模块会根据相应通信技术的规范来执行包收发的操作，这意味着端口模块是以实际的发送方或者接收方的身份来收发网络包
        的。以以太网端口为例，路由器的端口具有MAC地址[插图]，因此它就能够成为以太网的发送方和接收方
     ####3.3.2路由表中的信息
     路由器和交换机的大体思路是类似的，不过具体的工作过程有所不同。交换机是通过MAC头部中的接收方MAC地址来判断转发目标的，而路由器
        则是根据IP头部中的IP地址来判断的。由于使用的地址不同，记录转发目标的表的内容也会不同
     最左侧的目标地址列记录的是接收方的信息。这里可能不是很容易理解，实际上这里的IP地址只包含表示子网的网络号部分的比特值，而表示
        主机号部分的比特值全部为0[插图]
     路由表的子网掩码列只是用来在匹配目标地址时告诉路由器应该匹配多少个比特。而且，目标地址中的地址和实际子网的网络号可能并不完全
        相同，但即便如此，路由器依然可以正常工作。
     路由表的子网掩码列只表示在匹配网络包目标地址时需要对比的比特数量
     接下来在子网掩码的右边还有网关和接口两列，它们表示网络包的转发目标。根据目标地址和子网掩码匹配到某条记录后，路由器就会将网络
        包交给接口列中指定的网络接口（即端口）[插图]，并转发到网关列中指定的IP地址。
     对路由表进行维护的方法有几种，大体上可分为以下两类。（a）由人手动维护路由记录（b）根据路由协议机制，通过路由器之间的信息交换
        由路由器自行维护路由表的记录
     ####3.3.3路由器的包接收操作
     首先，信号到达网线接口部分，其中的PHY（MAU）模块和MAC模块将信号转换为数字信息，然后通过包末尾的FCS进行错误校验，如果没问题则
        检查MAC头部中的接收方MAC地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。如果包的接收方MAC地址不
        是自己，说明这个包是发给其他设备的，如果接收这个包就违反了以太网的规则。
     ####3.3.4查询路由表确定输出端口
     完成包接收操作之后，路由器就会丢弃包开头的MAC头部。MAC头部的作用就是将包送达路由器，其中的接收方MAC地址就是路由器端口的MAC地
        址。因此，当包到达路由器之后，MAC头部的任务就完成了，于是MAC头部就会被丢弃。
     然而，有时候路由表中会存在网络号长度相同的多条记录，例如考虑到路由器或网线的故障而设置的备用路由就属于这种情况。这时，需要根
        据跃点计数的值来进行判断。跃点计数越小说明该路由越近，因此应选择跃点计数较小的记录。
     如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过ICMP[插图]消息告知发送方[插图]。这里的处理方式和交换机不同，原因
        在于网络规模的大小。
     ####3.3.5找不到匹配路由时选择默认路由
     路由表中子网掩码为0.0.0.0的记录表示“默认路由”
     ####3.3.6包的有效期
     从路由表中查找到转发目标之后，网络包就会被转交给输出端口，并最终发送出去
     第一个工作是更新IP头部中的TTL（Time to Live，生存时间）字段（参见第2章的表2.2）。TTL字段表示包的有效期，包每经过一个路由器
        的转发，这个值就会减1，当这个值变成0时，就表示超过了有效期，这个包就会被丢弃。
     ####3.3.7通过分片功能拆分大网络包
     路由器的端口并不只有以太网一种，也可以支持其他局域网或专线通信技术。不同的线路和局域网类型各自能传输的最大包长度也不同，因此
        输出端口的最大包长度可能会小于输入端口[插图]。即便两个端口的最大包长度相同，也可能会因为添加了一些头部数据而导致包的实际
        长度发生变化，ADSL、FTTH等宽带接入技术中使用的PPPoE[插图]协议就属于这种情况。无论哪种情况，一旦转发的包长度超过了输出端
        口能传输的最大长度，就无法直接发送这个包了。
     遇到这种情况，可以使用IP协议中定义的分片功能对包进行拆分，缩短每个包的长度。需要注意的是，这里说的分片和第2章介绍的TCP对数据
        进行拆分的机制是不同的。TCP拆分数据的操作是在将数据装到包里之前进行的，换句话说，拆分好的一个数据块正好装进一个包里。从IP
        分片的角度来看，这样一个包其实是一个未拆分的整体，也就是说，分片是对一个完整的包再进行拆分的过程。
     如果查询标志字段发现不能分片，那么就只能丢弃这个包，并通过ICMP消息通知发送方。否则，就可以按照输出端口MTU对数据进行依次拆分
        了。在分片中，TCP头部及其后面的部分都是可分片的数据，尽管TCP头部不属于用户数据，但从IP来看也是TCP请求传输的数据的一部分。
        数据被拆分后，每一份数据前面会加上IP头部，其大部分内容都和原本的IP头部一模一样，但其中有部分字段需要更新，这些字段用于记录
        分片相关的信息
     ####3.3.8路由器的发送操作和计算机相同
     首先，为了判断MAC头部中的MAC地址应该填写什么值，我们需要根据路由表的网关列判断对方的地址。如果网关是一个IP地址，则这个IP地址
        就是我们要转发到的目标地址；如果网关为空[插图]，则IP头部中的接收方IP地址就是要转发到的目标地址。知道对方的IP地址之后，接下
        来需要通过ARP[插图]根据IP地址查询MAC地址，并将查询的结果作为接收方MAC地址。路由器也有ARP缓存，因此首先会在ARP缓存中查询，
        如果找不到则发送ARP查询请求
     路由器判断下一个转发目标的方法如下。●如果路由表的网关列内容为IP地址，则该地址就是下一个转发目标。●如果路由表的网关列内容为空，
        则IP头部中的接收方IP地址就是下一个转发目标。
     网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。例如，当以太网工作在半双工模式
        时，需要先确认线路中没有其他信号后才能发送，如果检测到碰撞，则需要等待一段时间后重发。如果以太网工作在全双工模式，则不需要
        确认线路中的信号，可以直接发送。
     ####3.3.9路由器与交换机的关系
     要理解两者之间的关系，关键点在于计算机在发送网络包时，或者是路由器在转发网络包时，都需要在前面加上MAC头部。之前的讲解都是说在
        开头加上MAC头部，如果看图3.16大家可以发现，准确的说法应该是将IP包装进以太网包的数据部分中。也就是说，给包加上MAC头部并发送，
        从本质上说是将IP包装进以太网包的数据部分中，委托以太网去传输这些数据。IP协议本身没有传输包的功能，因此包的实际传输要委托以太
        网来进行。路由器是基于IP设计的，而交换机是基于以太网设计的，因此IP与以太网的关系也就是路由器与交换机的关系。换句话说，路由器
        将包的传输工作委托给交换机来进行[插图]。当然，这里讲的内容只适用于原原本本实现IP和以太网机制的纯粹的路由器和交换机，实际的路
        由器有内置交换机功能的，比如用于连接互联网的家用路由器就属于这一种，对于这种路由器，上面内容可能就不适用了。但是，如果把这种
        “不纯粹”的路由器拆分成“纯粹”的路由器和“纯粹”的交换机，则它们各自都适用上面的内容。
     从包的转发目标也可以看出路由器和交换机之间的委托关系。IP并不是委托以太网将包传输到最终目的地，而是传输到下一个路由器。在创建
        MAC头部时，也是从IP的路由表中查找出下一个路由器的IP地址，并通过ARP查询出MAC地址，然后将MAC地址写入MAC头部中的，这表示IP对
        以太网的委托只是将包传输到下一个路由器就行了。当包到达下一个路由器后，下一个路由器又会重新委托以太网将包传输到再下一个路由
        器。随着这一过程反复执行，包就会最终到达IP的目的地，也就是通信的对象。
     网络并非只有以太网一种，还有无线局域网，以及接入互联网的通信线路，它们和IP之间的关系又是什么样的呢？其实只要将以太网替换成无
        线局域网、互联网线路等通信规格就可以了。也就是说，如果和下一个路由器之间是通过无线局域网连接的，那么就委托无线局域网将包
        传输过去；如果是通过互联网线路连接的，那么就委托它将包传输过去。
     ###3.4路由器的附加功能
     ####3.4.1通过地址转换有效利用IP地址
     首先，我们先了解一下地址转换功能出现的背景。所谓地址，就是用来识别每一台设备的标志，因此每台设备都应该有一个唯一不重复的地址，
        就好像如果很多人的地址都一样，那么快递员就不知道该把包裹送给谁了。网络也是一样，本来互联网中所有的设备都应该有自己的固定地
        址，而且最早也确实是这样做的。比如，公司内网需要接入互联网的时候，应该向地址管理机构申请IP地址，并将它们分配给公司里的每台
        设备。换句话说，那个时候没有内网和外网的区别，所有客户端都是直接连接到互联网的
     尽管互联网原本是这样设计的，但进入20世纪90年代之后，互联网逐步向公众普及，接入互联网的设备数量也快速增长，如此一来，情况就发生
        了变化。如果还用原来的方法接入，过不了多久，可分配的地址就用光了。如果不能保证每台设备有唯一不重复的地址，就会从根本上影响
        网络包的传输，这是一个非常严重的问题。如果任由这样发展下去，不久的将来，一旦固定地址用光，新的设备就无法接入了，互联网也就
        无法继续发展了。
     解决这个问题的关键在于固定地址的分配方式。举个例子，假如有A、B两家公司，它们的内网是完全独立的。这种情况下，两家公司的内网之
        间不会有网络包流动，即使A公司的某台服务器和B公司的某台客户端具有相同的IP地址也没关系，因为它们之间不会进行通信。只要在每
        家公司自己的范围内，能够明确判断网络包的目的地就可以了，是否和其他公司的内网地址重复无关紧要，只要每个公司的网络是相互独立
        的，就不会出现问题。
     公司内部设备就不需要分配固定地址了，从而大幅节省了IP地址。当然，就算是公司内网，也不是可以随便分配地址的，因此需要设置一定的
        规则，规定某些地址是用于内网的，这些地址叫作私有地址，而原来的固定地址则叫作公有地址
     首先，TCP连接操作的第一个包被转发到互联网时，会像图3.18这样，将发送方IP地址从私有地址改写成公有地址。这里使用的公有地址是地
        址转换设备[插图]的互联网接入端口的地址。与此同时，端口号也需要进行改写，地址转换设备会随机选择一个空闲的端口。然后，改写
        前的私有地址和端口号，以及改写后的公有地址和端口号，会作为一组相对应的记录保存在地址转换设备内部的一张表中。
     在后面的包收发过程中，地址转换设备需要根据对应表查找私有地址和公有地址的对应关系，再改写地址和端口号之后进行转发。当数据收发
        结束，进入断开阶段，访问互联网的操作全部完成后，对应表中的记录就会被删除。
     现在我们使用的地址转换机制是同时改写地址和端口号的，但早期的地址转换机制是只改写地址，不改写端口号的。
     包过滤也是路由器的一个重要附加功能，刚才的地址转换看起来有点复杂，不过包过滤的机制并不复杂。包过滤就是在对包进行转发时，根据
        MAC头部、IP头部、TCP头部的内容[插图]，按照事先设置好的规则决定是转发这个包，还是丢弃这个包。我们通常说的防火墙设备或软件，
        大多数都是利用这一机制来防止非法入侵的
##第四章 通过接入网接入互联网内部    
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
      